<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D≈©ng ƒê·∫πp Trai</title>

    <link rel="shortcut icon" href="./icon.png" type="image/x-icon">

    <!-- Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script&display=swap" rel="stylesheet">

    <!-- CSS Crush Killer (n·∫øu b·∫°n c√≥ file n√†y trong folder css/) -->
    <!-- N·∫øu kh√¥ng c√≥ th√¨ x√≥a d√≤ng d∆∞·ªõi -->
    <link rel="stylesheet" href="css/07928e508fb46a7b.css">

    <style>
        * {
            margin: 0;
            padding: 0;
        }

        html,
        body {
            height: 100%;
            touch-action: none;
        }

        body {
            overflow: hidden;
            display: flex;
            background: #111;
            
            transform-style: preserve-3d;
            font-family: 'Dancing Script', cursive;
        }

        /* ================= 3D IMAGE EFFECT ================= */
        #drag-container,
        #spin-container {
            position: relative;
            display: flex;
            margin: auto;
            transform-style: preserve-3d;
            transform: rotateX(-10deg);
            z-index: 100;
        }

        #drag-container img,
        #drag-container video {
            transform-style: preserve-3d;
            position: absolute;
            left: 0;
            top: 0;
            max-width: 120%;
            max-height: 120%;
            line-height: 200px;
            font-size: 50px;
            text-align: center;
            box-shadow: 0 0 8px #fff;
            -webkit-box-reflect: below 10px linear-gradient(transparent, transparent, #0005);
        }

        #drag-container img:hover,
        #drag-container video:hover {
            box-shadow: 0 0 15px #fffd;
            -webkit-box-reflect: below 10px linear-gradient(transparent, transparent, #0007);
        }

        #drag-container p {
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translate(-50%, -50%) rotateX(90deg);
            color: rgb(0, 195, 255);
            animation: fadein ease 15s;
            font-size: 4vw;
        }

        @keyframes fadein {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        #ground {
            width: 900px;
            height: 900px;
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translate(-50%, -50%) rotateX(90deg);
            background: radial-gradient(circle farthest-side, #9993, transparent);
        }

        @keyframes spin {
            from {
                transform: rotateY(0deg);
            }

            to {
                transform: rotateY(360deg);
            }
        }

        @keyframes spinRevert {
            from {
                transform: rotateY(360deg);
            }

            to {
                transform: rotateY(0deg);
            }
        }

        /* ================= CANVAS HEART ================= */
        #canvas {
            background-color: transparent;
            color: transparent;
            margin: 0;
            overflow: hidden;
            background-repeat: no-repeat;
            width: 100vw;
            height: 100vh;
        }

        #canva {
            position: absolute;
            top: 0px;
            right: 0px;
            overflow: hidden;
            z-index: 1;
        }

        /* ================= CONTENT CRUSH KILLER ================= */
        .content {
    position: fixed;
    bottom: 30px;
    left: 50%;
    transform: translateX(-50%);
    text-align: center;
    z-index: 9999;
    width: 90%;
    max-width: 650px;
    padding: 20px;

    background: transparent;
    box-shadow: none;
    border-radius: 0;
    backdrop-filter: none;
}

        .content h2 {
            font-size: 32px;
            margin-bottom: 10px;
            color: rgb(0, 195, 255);
        }

        .content h4 {
            font-size: 20px;
            margin-bottom: 18px;
            color: white;
        }

        .btn-group {
            display: flex;
            justify-content: center;
            gap: 20px;
        }

        #yes,
        #no {
            padding: 12px 22px;
            font-size: 18px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            color: white;
            transition: 0.3s;
            font-family: 'Dancing Script', cursive;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
        }

        #yes {
            background: #3b82f6;
        }

        #no {
            background: #f43f5e;
        }

        #yes:hover,
        #no:hover {
            transform: scale(1.12);
        }

        #music-container {
            position: absolute;
            top: 0;
            left: 0;
            display: none;
        }
    </style>
</head>

<body>

    <!-- 3D Images -->
    <div id="drag-container">
        <div id="spin-container">
          <img src="/img/z7537684129742_9397347e75d5c3dd0460eebb9cf47920.jpg" alt="">
            <img src="/img/z7537684100610_923016cb578f7a15611ac53b99f72d64.jpg" alt="">
            <img src="/img/z7537684106428_2748dd6671b054f8b2dfb713e7cbdae5.jpg" alt="">
            <img src="/img/z7537684109898_8e4b46dcccb016270b620f6e1def2ad0.jpg" alt="">
            <img src="/img/z7537684113449_86376f735800f3764d9a530e283d2227.jpg" alt="">
            <img src="/img/z7537684119445_f4789cb49e7fa945b29953d69992877b.jpg" alt="">
            <img src="/img/z7537684120224_85101cb40e91e1bc5c336e78d2fa06a9.jpg" alt="">
            <img src="/img/z7537684133624_6dbd0e541d0ddc5950402a6b7c42a01c.jpg" alt="">

            <p>D≈©ngdeptrai</p>
        </div>

        <div id="ground"></div>
    </div>

    <!-- WebGL Canvas -->
    <div id="canva">
        <canvas id="canvas"></canvas>
    </div>

    <!-- Crush Killer Content -->
    <div class="content">
        <header>
            <h2 class="mt-24" style="color: red;">&hearts;</h2>
            <h4 class="mt-16" style="color: red;">T·ªëi mai ƒëi xem ph√°o hoa nh√°!!!</h4>
        </header>

        <div class="btn-group">
            <button id="yes" type="button">ƒê·ªìng √Ω</button>
            <button id="no" type="button">!ƒê·ªìng √Ω</button>
        </div>
    </div>

    <!-- Music -->
    <audio src="./music.mp3" autoplay loop></audio>

    <script>
        // ============== 3D IMAGE EFFECT SCRIPT ==============
        var radius = 240;
        var autoRotate = true;
        var rotateSpeed = -60;
        var imgWidth = 120;
        var imgHeight = 170;

        setTimeout(init, 1000);

        var odrag = document.getElementById('drag-container');
        var ospin = document.getElementById('spin-container');
        var aImg = ospin.getElementsByTagName('img');
        var aVid = ospin.getElementsByTagName('video');
        var aEle = [...aImg, ...aVid];

        ospin.style.width = imgWidth + "px";
        ospin.style.height = imgHeight + "px";

        var ground = document.getElementById('ground');
        ground.style.width = radius * 3 + "px";
        ground.style.height = radius * 3 + "px";

        function init(delayTime) {
            for (var i = 0; i < aEle.length; i++) {
                aEle[i].style.transform = "rotateY(" + (i * (360 / aEle.length)) + "deg) translateZ(" + radius + "px)";
                aEle[i].style.transition = "transform 1s";
                aEle[i].style.transitionDelay = delayTime || (aEle.length - i) / 4 + "s";
            }
        }

        function applyTranform(obj) {
            if (tY > 180) tY = 180;
            if (tY < 0) tY = 0;
            obj.style.transform = "rotateX(" + (-tY) + "deg) rotateY(" + (tX) + "deg)";
        }

        function playSpin(yes) {
            ospin.style.animationPlayState = (yes ? 'running' : 'paused');
        }

        var sX, sY, nX, nY, desX = 0,
            desY = 0,
            tX = 0,
            tY = 10;

        if (autoRotate) {
            var animationName = (rotateSpeed > 0 ? 'spin' : 'spinRevert');
            ospin.style.animation = `${animationName} ${Math.abs(rotateSpeed)}s infinite linear`;
        }

        document.onpointerdown = function (e) {
            clearInterval(odrag.timer);
            e = e || window.event;
            var sX = e.clientX,
                sY = e.clientY;

            this.onpointermove = function (e) {
                e = e || window.event;
                var nX = e.clientX,
                    nY = e.clientY;
                desX = nX - sX;
                desY = nY - sY;
                tX += desX * 0.1;
                tY += desY * 0.1;
                applyTranform(odrag);
                sX = nX;
                sY = nY;
            };

            this.onpointerup = function (e) {
                odrag.timer = setInterval(function () {
                    desX *= 0.95;
                    desY *= 0.95;
                    tX += desX * 0.1;
                    tY += desY * 0.1;
                    applyTranform(odrag);
                    playSpin(false);
                    if (Math.abs(desX) < 0.5 && Math.abs(desY) < 0.5) {
                        clearInterval(odrag.timer);
                        playSpin(true);
                    }
                }, 17);
                this.onpointermove = this.onpointerup = null;
            };

            return false;
        };

        document.onmousewheel = function (e) {
            e = e || window.event;
            var d = e.wheelDelta / 20 || -e.detail;
            radius += d;
            init(1);
        };

        // ============== BUTTON EVENT ==============
        document.getElementById("yes").onclick = function () {
            alert("T·ªõ bi·∫øt ch·ªçn c√°i n√†y m√† üò≥ T·ªëi mai t·ªõ qua ƒë√≥n nha <3");
        };

        document.getElementById("no").onmouseover = function () {
            let x = Math.random() * (window.innerWidth - this.offsetWidth);
            let y = Math.random() * (window.innerHeight - this.offsetHeight);
            this.style.position = "fixed";
            this.style.left = x + "px";
            this.style.top = y + "px";
        };

        // ============== WEBGL HEART EFFECT ==============
        var canvas = document.getElementById("canvas");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        var gl = canvas.getContext('webgl');
        if (!gl) {
            console.error("Unable to initialize WebGL.");
        }

        var time = 0.0;

        var vertexSource = `
        attribute vec2 position;
        void main() {
            gl_Position = vec4(position, 0.0, 1.0);
        }
        `;

        var fragmentSource = `
        precision highp float;

        uniform float width;
        uniform float height;
        vec2 resolution = vec2(width, height);

        uniform float time;

        #define POINT_COUNT 8

        vec2 points[POINT_COUNT];
        const float speed = -0.5;
        const float len = 0.25;
        float intensity = 1.3;
        float radius = 0.008;

        float sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C){    
            vec2 a = B - A;
            vec2 b = A - 2.0*B + C;
            vec2 c = a * 2.0;
            vec2 d = A - pos;

            float kk = 1.0 / dot(b,b);
            float kx = kk * dot(a,b);
            float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;
            float kz = kk * dot(d,a);      

            float res = 0.0;

            float p = ky - kx*kx;
            float p3 = p*p*p;
            float q = kx*(2.0*kx*kx - 3.0*ky) + kz;
            float h = q*q + 4.0*p3;

            if(h >= 0.0){ 
                h = sqrt(h);
                vec2 x = (vec2(h, -h) - q) / 2.0;
                vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));
                float t = uv.x + uv.y - kx;
                t = clamp( t, 0.0, 1.0 );

                vec2 qos = d + (c + b*t)*t;
                res = length(qos);
            }else{
                float z = sqrt(-p);
                float v = acos( q/(p*z*2.0) ) / 3.0;
                float m = cos(v);
                float n = sin(v)*1.732050808;
                vec3 t = vec3(m + m, -n - m, n - m) * z - kx;
                t = clamp( t, 0.0, 1.0 );

                vec2 qos = d + (c + b*t.x)*t.x;
                float dis = dot(qos,qos);

                res = dis;

                qos = d + (c + b*t.y)*t.y;
                dis = dot(qos,qos);
                res = min(res,dis);

                qos = d + (c + b*t.z)*t.z;
                dis = dot(qos,qos);
                res = min(res,dis);

                res = sqrt( res );
            }

            return res;
        }

        vec2 getHeartPosition(float t){
            return vec2(16.0 * sin(t) * sin(t) * sin(t),
                            -(13.0 * cos(t) - 5.0 * cos(2.0*t)
                            - 2.0 * cos(3.0*t) - cos(4.0*t)));
        }

        float getGlow(float dist, float radius, float intensity){
            return pow(radius/dist, intensity);
        }

        float getSegment(float t, vec2 pos, float offset, float scale){
            for(int i = 0; i < POINT_COUNT; i++){
                points[i] = getHeartPosition(offset + float(i)*len + fract(speed * t) * 6.28);
            }

            vec2 c = (points[0] + points[1]) / 2.0;
            vec2 c_prev;
            float dist = 10000.0;

            for(int i = 0; i < POINT_COUNT-1; i++){
                c_prev = c;
                c = (points[i] + points[i+1]) / 2.0;
                dist = min(dist, sdBezier(pos, scale * c_prev, scale * points[i], scale * c));
            }
            return max(0.0, dist);
        }

        void main(){
            vec2 uv = gl_FragCoord.xy/resolution.xy;
            float widthHeightRatio = resolution.x/resolution.y;
            vec2 centre = vec2(0.5, 0.5);
            vec2 pos = centre - uv;
            pos.y /= widthHeightRatio;
            pos.y += 0.02;
            float scale = 0.000015 * height;

            float t = time;

            float dist = getSegment(t, pos, 0.0, scale);
            float glow = getGlow(dist, radius, intensity);

            vec3 col = vec3(0.0);

            col += 10.0*vec3(smoothstep(0.003, 0.001, dist));
            col += glow * vec3(1.0,0.05,0.3);

            dist = getSegment(t, pos, 3.4, scale);
            glow = getGlow(dist, radius, intensity);

            col += 10.0*vec3(smoothstep(0.003, 0.001, dist));
            col += glow * vec3(0.1,0.4,1.0);

            col = 1.0 - exp(-col);
            col = pow(col, vec3(0.4545));

            gl_FragColor = vec4(col,1.0);
        }
        `;

        window.addEventListener('resize', onWindowResize, false);

        function onWindowResize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.uniform1f(widthHandle, window.innerWidth);
            gl.uniform1f(heightHandle, window.innerHeight);
        }

        function compileShader(shaderSource, shaderType) {
            var shader = gl.createShader(shaderType);
            gl.shaderSource(shader, shaderSource);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                throw "Shader compile failed with: " + gl.getShaderInfoLog(shader);
            }
            return shader;
        }

        function getAttribLocation(program, name) {
            var attributeLocation = gl.getAttribLocation(program, name);
            if (attributeLocation === -1) {
                throw 'Cannot find attribute ' + name + '.';
            }
            return attributeLocation;
        }

        function getUniformLocation(program, name) {
            var uniformLocation = gl.getUniformLocation(program, name);
            if (uniformLocation === -1) {
                throw 'Cannot find uniform ' + name + '.';
            }
            return uniformLocation;
        }

        var vertexShader = compileShader(vertexSource, gl.VERTEX_SHADER);
        var fragmentShader = compileShader(fragmentSource, gl.FRAGMENT_SHADER);

        var program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        gl.useProgram(program);

        var vertexData = new Float32Array([
            -1.0, 1.0,
            -1.0, -1.0,
            1.0, 1.0,
            1.0, -1.0,
        ]);

        var vertexDataBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexDataBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);

        var positionHandle = getAttribLocation(program, 'position');

        gl.enableVertexAttribArray(positionHandle);
        gl.vertexAttribPointer(positionHandle, 2, gl.FLOAT, false, 2 * 4, 0);

        var timeHandle = getUniformLocation(program, 'time');
        var widthHandle = getUniformLocation(program, 'width');
        var heightHandle = getUniformLocation(program, 'height');

        gl.uniform1f(widthHandle, window.innerWidth);
        gl.uniform1f(heightHandle, window.innerHeight);

        var lastFrame = Date.now();
        var thisFrame;

        function draw() {
            thisFrame = Date.now();
            time += (thisFrame - lastFrame) / 1000;
            lastFrame = thisFrame;

            gl.uniform1f(timeHandle, time);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            requestAnimationFrame(draw);
        }

        draw();
    </script>

</body>

</html>
